# 상속
- 클래스는 메서드나 프로퍼티 등을 다른 클래스로부터 상속받을 수 있다. 
- 어떤 클래스로부터 상속을 받으면 상속받은 클래스는 그 어떤 클래스의 자식클래스(Subclass, Child-class)라고 표현한다. 자식클래스에게 자신의 특성을 물려준 클래스는 부모클래스(Superclassm, Parents-class)라고 표현한다.
  - 상속은 스위프트의 다른 타입과 클래스를 구별 짓는 클래스만의 특징이다.
- 스위프트의 클래스는 부모클래스로부터 물려받은 메서드를 호출할 수 있고 프로퍼티에 접근할 수 있으며 서브스크립트도 사용할 수 있다. 또, 부모클래스로부터 물려받은 메서드, 프로퍼티 서브스크립트 등을 자신만의 내용으로 재정의할 수도 있다. 스위프트는 부모클래스의 요소를 자식클래스에서 재정의할 때 자식클래스가 부모클래스의 요소들을 재정의한다는 것을 명확히 확인해줘야한다.
- 상속받은 프로퍼티에 프로퍼티의 값이 변경되었을때 알려주는 프로퍼티 감시자도 구현할 수 있다. 연산 프로퍼티를 정의해준 클래스에서는 연산 프로퍼티에 프로퍼티 감시자를 구현할 수 없지만, 부모클래스에서 연산 프로퍼티로 정의한 프로퍼티든 저장 프로퍼티로 정의한 프로퍼티든 자식클래스에서는 프로퍼티 감시자를 구현할 수 있다.
- 다른 클래스로부터 상속을 받지 않은 클래스를 기반클래스(Base clasee)라고 한다. 

<br/>

---------
# 1. 클래스 상속
- 수직으로 클래스를 확장할 수 있는 상속이다. 상속은 기반클래스를 다른 클래스에서 물려받는 것을 말한다. 부모클래스의 메서드, 프로퍼티 등을 재정의하거나, 기반클래스의 기능이나 프로퍼티를 물려받고 자신의 기능 추가할 수 있다.
- 클래스 이름 뒤에 콜론을 붙이고 다른 클래스 이름을 써주면 뒤에 오는 클래스의 기능을 앞의 클래스가 상속받을 것임을 뜻합니다.
- 다른 클래스를 상속받으면 똑같은 기능을 구현하기 위하여 코드를 다시 작성할 필요가 없으므로 코드를 재사용하기 용이하고 더불어 기능을 확장할 때 기존 클래스를 변경하지 않고도 새로운 추가 기능을 구현한 클래스를 정의할 수 있다. 

<br/>

---------
# 2. 재정의 
- 자식클래스는 부모클래스로부터 물려받은 특성(인스턴스 메서드, 타입 메서드, 인스턴스 프로퍼티, 타입 프로퍼티, 서브스크립트 등)을 그대로 사용하지 않고 자신만의 기능으로 변경하여 사용할 수 있다. 이르 재정의(Override)라고 한다.
- 만약 자식클래스에서 부모클래스의 특성을 재정의했을 때, 부모클래스의 특성을 자식클래스에서 사용하고 싶다면 super 프로퍼티를 사용하면 된다. 즉, 자식클래스에서 특성을 재정의했지만 필요에 따라 부모클래스의 특성을 활용하고 싶을 때 super를 사용한다. super 키워드를 타입 메서드 내에서 사용한다면, 부모클래스의 타입 메서드와 타입 프로퍼티에 접근할 수 있으며 인스턴스 메서드 내에서 사용한다면, 부모클래스의 인스턴스 메서드와 인스턴스 프로퍼티, 서브크스립트에 접근할 수 있다.

## 2.1. 메서드 재정의
- 부모클래스로부터 상속받은 인스턴스 메서드나 타입 메서드를 자식클래스에서 용도에 맞도록 재정의할 수 있다. 

## 2.2. 프로퍼티 재정의
- 메서드와 마찬가지로 부모클래스로부터 상속받은 인스턴스 프로퍼티나 타입 프로퍼티를 자식 클래스에서 용도에 맞게 재정의할 수 있다. 프로퍼티를 재정의할 때는 저장 프로퍼티로 재정의할 수 있다. 프로퍼티를 재정의할 때는 저장 프로퍼티로 재정의할 수는 없다. 프로퍼티를 재정의한다는 것은 프로퍼티 자체가 아니라 프로퍼티의 접근자(Getter), 설정자(Setter), 프로퍼티 감시자(Propertty Observer)등을 재정의하는 것을 의미한다.
- 조상클래스에서 저장 프로퍼티로 정의한 프로퍼티는 물론이고 연산 프로퍼티로 정의한 프로퍼티도 접근자와 설정자를 재정의할 수 있다. 프로퍼티를 상속받은 자식클래스에서는 조상클래스의 프로퍼티 종류(저장, 연산 등)는 알지 못하고 단지 이름과 타입만을 알기 때문이다. 재정의하려는 프로퍼티는 조상클래스 프로퍼티의 이름과 타입이 일치해야 한다. 만약 조상클래스에 없는 프로퍼티를 재정의하려고 한다면 메서드와 마찬가지로 컴파일 오류가 발생한다.
- 조상클래스에서 읽기 전용 프로퍼티였더라도 자식클래스에서 읽고 쓰기가 가능한 프로퍼티로 재정의해줄 수도 있다. 그러나 읽기 쓰기 모두 가능했던 프로퍼티를 읽기 전용으로 재정의해줄 수는 없다.
- 읽기 쓰기가 모두 가능한 프로퍼티를 재정의할 때 설정자만 따로 재정의할 수는 없다. 즉, 접근자와 설정자를 모두 재정의해야 한다. 만약 접근자에 따로 기능 변경이 필요 없다면 부모클래스의 접근자를 사용하여 값을 받아와 반환해주면 된다.

## 2.3. 프로퍼티 감시자 재정의
- 
