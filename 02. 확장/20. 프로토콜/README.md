# 프로토콜
- 스위프트에서 프로토콜 지향 프로그래밍(Protocol Oriented Programming)을 사용하고 있으며 프로토콜에 대해 알아보고자한다.

# 1. 프로토콜이란
- 프로토콜(Protocol)은 특정 역할을 하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 청사진을 정의한다. 구조체, 클래스, 열거형은 프로토콜을 채택(Adopted)해서 특정 기능을 실행하기 위한 프로토콜의 요구 사항을 실제로 구현할 수 있다. 어떤 프로토콜의 요구사항은 모두 따르는 타입은 '해당 프로토콜을 준수한다(Conform)'고 표현한다. 타입에서 프로토콜의 요구사항을 충족시키려면 프로토콜이 제시하는 청사진의 기능을 모두 구현해야한다.
  - 즉 프로토콜은 정의를하고 제시할 뿐이지 스스로 기능을 구현하지는 않는다.

<br/>

----------

# 2. 프로토콜 채택
- 프로토콜은 구조체, 클래스, 열거형의 모양과 비슷하게 정의할 수 있으며 protocol 키워드를 사용한다. 구조체, 클래스, 열거형 등에서 프로토콜을 채택하려면 타입 이름뒤에 콜론을 붙여준 후 채택한 프로토콜 이름을 쉼표로 명시해준다.
``` swift
struct SomeStruct: AProtocol, AnotherProtol {
}
```

<br/>

----------

# 3. 프로토콜 요구사항 
- 프로토콜은 타입이 특정 기능을 실행하기 위해 필요한 기능을 요구한다. 프로토콜이 자신이 채택한 타입에 요구하는 사항은 프로퍼티나 메서드와 같은 기능들이다.

## 3.1. 프로퍼티 요구
- 프로토콜은 자신을 채택한 타입이 어떤 프로퍼티를 구현해야 하는지 요구할 수 있다. 그렇지만 프로토콜은 그 프로퍼티의 종류(연산 프로퍼티인지, 저장 프로퍼티인지 등)는 따로 신경 쓰지 않는다. 프로토콜을 채택한 타입은 프로토콜이 요구하는 프로퍼티의 이름과 타입만 맞도록 구현해주면 된다. 다만 프로퍼티를 읽기 전용으로 할지 혹은 읽고 쓰기가 모두 가능하게 할지는 프로토콜이 정해야한다.
- 만약 프로토콜이 읽고 쓰기가 가능한 프로퍼티를 요구한다면 읽기만 가능한 상수 저장 프로퍼티 또는 읽기 전용 연산 프로퍼티를 구현할 수 없다. 만약 프로토콜이 읽기 가능한 프로퍼티를 요구한다면 타입에 프로퍼티를 구현할 때 상수 저장 프로퍼티나 읽기 전용 연산 프로퍼티를 포함해서 어떤 식으로든 프로퍼티를 구현할 수 있다. 쓰기만 가능한 프로퍼티는 없으니 타입에 구현해주는 프로퍼티는 무엇이 되어도 상관없다.
- 프로토콜의 프로퍼티 요구사항은 항상 var 키워드를 사용한 변수 프로퍼티로 정의한다. 읽기 쓰기가 모두 가능한 프로퍼티는 프로퍼티의 정의 뒤에 { get set }이라고 명시하며, 읽기 전용은 프로퍼티 정의 뒤에 { get }이라고 명시한다.

## 3.2. 메서드 요구
- 프로토콜은 특정 인스턴스 메서드나 타입 메서드를 요구할 수도 있다. 프로토콜이 요구할 메서드는 프로토콜 정의에서 작성한다. 다만 메서드의 실제 구현부인 중괄호 부분은 제외하고 메서드의 이름, 매개변수, 반환 타입 등만 작성하며 가변 매개변수도 허용한다.
- 프로토콜의 메서드 요구에서는 매개변수 기본값을 지정할 수 없다. 타입 메서드를 요구할 때는 타입 프로퍼티 요구와 마찬가지로 앞에 static 키워드를 명시한다. static 키워드를 사용하여 요구한 타입 메서드를 클래스에서 실제 구현할 때는 static 키워드나 class 키워드 어느 쪽을 사용해도 무방한다. 

## 3.3. 가변 메서드 요구
- 메서드가 인스턴스 내부의 값을 변경할 필요가 있다. 값 타입(구조체와 열거형)의 인스턴스 메서드에서 자신의 내부의 값을 변경하고자 할 때는 메서드의 func 키워드 앞에 mutating 키워드를 적어 메서드에서 인스턴스 내부의 값을 변경한다는 것을 확실히 해줘야한다.
- 프로토콜이 어떤 타입이든 간에 인스턴스 내부의 값을 변경해야 하는 메서드를 요구하려면 프로토콜의 메서드 정의 앞에 mutating 키워드를 명시해야한다. 참조 타입인 클래스의 메서드 앞에서 mutating 키워드를 명시하지 않아도 인스턴스 내부 값을 바꾸는 데 문제가 없지만, 값 타입인 구조체와 열거형의 메서드 앞에는 mutating 키워드를 붙여 가변 메서드 요구가 필요하다. 
  - 하지만 프로토콜에 mutating 키워드를 사용한 메서드 요구가 있다고 하더라도 클래스 구현에서는 mutating 키워드가 필요없다.

## 3.4. 이니셜라이저 요구
- 프로토콜은 프로퍼티, 메서드 등과 마찬가지로 특정한 이니셜라이저를 요구할 수도 있다. 프로토콜에서 이니셜라이저를 요구하려면 메서드 요구와 마찬가지로 이니셜라이저를 정의하지만 구현은 하지 않는다. 즉, 이니셜라이저의 매개변수를 지정하기만 할 뿐, 중괄호를 포함한 이니셜라이저 구현은 하지않는다.
- 구조체는 상속할 수 없기 때문에 이니셜라이저 요구에 대한 크게 신경쓸 필요가 없다.
- 클래스에서 프로토콜의 이니셜라이저 요구에 부합하는 이니셜라이저를 구현할 때는 이니셜라이저가 지정 이니셜라이저인지 편의 이니셜라이저인지는 중요하지 않다. 그러나 이니셜라이저 요구에 부합하는 이니셜라이저를 구현할 때는 required 식별자를 붙인 요구 이니셜라이저로 구현해야한다. 
- 만약 클래스 자체가 상속받을 수 없는 final 클래스라면 required 식별자를 붙여줄 필요가 없다. 상속할 수 없는 클래스의 요청 이니셜라이저 구현은 무의미하기 때문이다.
- 만약 특정 클래스에 프로토콜이 요구하는 이니셜라이저가 이미 구현되어 있는 상황에서 그 클래스를 상속받은 클래스가 있다면, required와 override 식별자를 모두 명시하여 프로토콜에서 요구하는 이니셜라이저를 구현해주어야한다.
- 프로토콜은 일반 이니셜라이저 외에도 실패 가능한 이니셜라이저를 요구할 수도 있다. 실패 가능한 이니셜라이저를 요구하는 프로토콜을 준수하는 타입은 해당 이니셜라이저를 구현할 때 실패 가능한 이니셜라이저로 구현해도, 일반적인 이니셜라이저로 구현해도 무방하다. 

<br/>

----------

# 4. 프로토콜의 상속과 클래스 전용 프토토콜
- 프로토콜은 하나 이상의 프로토콜을 상속받아 기존 프로토콜의 요구사항보다 더 많은 요구사항을 추가할 수 있다. 프로토콜 상속 문법은 클래스 상속 문법과 유사하다.
- 프로토콜의 상속 리스트에 class 키워드를 추가해 프로토콜이 클래스 타입에만 채택될 수 있도록 제한할 수도 있다. 클래스 전용 프로토콜로 제한해주기 위해서는 상속 리스트의 맨 처음에 class 키워드가 있어야만 한다.

<br/>

----------

# 5. 프로토콜 조합과 프로토콜 준수 확인
- 하나의 매개변수가 여러 프로토콜을 모두 준수하는 타입이어야 한다면 하나의 매개변수에 여러 프로토콜을 한 번에 조합하여 요구할 수 있다. 프로토콜을 조합하여 요구할 때는 SomeProtocol & AnotherProtocol과 같이 표현한다.
- 하나의 매개변수가 프로토콜을 둘 이상 요구할 수도 있다. 이때도 마찬가지로 앰퍼샌드(&)를 여러 프로토콜 이름 사이에 써주면된다. 
- 더불어 특정 클래스의 인스턴스 역할을 할 수 있는지 함께 확인할 수 있다. 구조체나 열거형 타입은 조합할 수 없다. 그리고 조합 중 클래스 타입은 한타입만 조합할 수 있다. 
- 타입 캐스팅에 사용하던 is와 as 연산자를 통해 대상이 프로토콜을 준수하는지 확인할 수도 있고, 특정 프로토콜로 캐스팅할 수 있다. 프로토콜을 준수하는지 확인하거나 다른 프로토콜로 캐스팅하는 방법은 타입캐스팅과 방법이 똑같다.

<br/>

----------

# 6. 프로토콜의 선택적 요구
- 프로토콜의 요구사항 중 일부를 요구사항으로 지정할 수 있다. 다만 먼저 고려해야할 사항이 있다.
- 선택적 요구사항을 정의하고 싶은 프로토콜은 objc 속성이 부여된 프로토콜이어야 한다. objc 속성은 해당 프로토콜을 Objective-C 코드에서 사용할 수 있도록 만드는 역할을 한다. 그렇지만 해당 프로토콜을 Objective-C 코드와 공유하고 싶지 않더라도, 혹은 프로젝트를 Objective-C 코드와 공유하지 않더라도 objc 속성이 부여되어야만 선택적 요구사항을 정의할 수 있다.
- objc 속성이 부여된 프로토콜을 클래스에서만 채택 가능하다. 열거형이나 구조체 등에서는 채택 불가능하다.
  - objc 속성을 사용하려면 애플의 Foundation 프레임워크 모듈을 임포트해야한다.
- 선택적 요구를 하면 프로토콜을 준수하는 타입에 해당 요구사항을 필수로 구현할 필요가 없다. 선택적 요구사항은 optional 식별자를 요구사항의 정의 앞에 붙여주면 된다.
- 서드나 프로퍼티를 선택적 요구사항으로 요구하게 되면 그 요구사항의 타입은 자동적으로 옵셔널이 된다. 

<br/>

----------

# 7. 프로토콜 변수와 상수
- 프로토콜 이름을 타입으로 갖는 변수 또는 상수에는 그 프로토콜을 준수하는 타입의 어떤 인스턴스라도 할당할 수 있다.
- 프로토콜은 프로토콜 이름만으로 자기 스스로 인스턴스를 생성하고 초기화할 수 없다. 하지만 변수나 상수를 생성하여 특정 프로토콜을 준수하는 타입의 인스턴스를 할당할 수는 있다.

<br/>

----------

# 8. 위임을 위한 프로토콜
- 위임(Delegation)은 클래스나 구조체가 자신의 책임이나 임무를 다른 타입의 인스턴스에게 위임하는 디자인 패턴이다. 책무를 위임하기 위해 정의한 프로토콜을 준수하는 타입은 자신에게 위임될 일정 책무를 할 수 있다는 것을 보장한다. 그렇기 때문에 다른 인스턴스에게 자신이 해야할 일을 믿고 맡길 수 있다. 위임은 사용자의 특정 행동에 반응하기 위해 사용되기도 하며, 비동기 처리에도 많이 사용한다.
- 위임 패턴(Delegation Pattern)은 애플의 프레임워크에서 사용하는 주요한 패턴 중 하나이다. 언어 자체로의 기능이 아닌 하나의 디자인 패턴이지만 애플의 프레임워크에서 중요하게 사용되는 만큼, 개념을 알아두면 앞으로 애플 플랫폼의 애플리케이션 만들때 도움이 된다. 애픙의 프레임워크에서 사용하는 위임 패턴을 위해 다양한 프로토콜이 '0000Delegate'라는 식의 이름으로 정의되어 있다. 
  - UITableView 타입의 인스턴스가 해야할 일을 위임받아 처리하는 인스턴스 UITableViewDelegate 프로토콜을 준수하면 된다. 위임받은 인스턴스, 즉 UITableViewDelegate 프로토콜을 준수하는 인스턴스 UITableView의 인스턴스가 해야할 일을 대신 처리해줄 수 있다. 
