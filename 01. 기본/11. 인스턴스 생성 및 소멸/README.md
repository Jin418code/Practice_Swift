# 인스턴스 생성 및 소멸
- 초기화는 클래스나 구조체 또는 열거형의 인스턴스를 사용하기 위한 준비 과정이다. 초기화가 된 인스턴스는 사용 후 소멸 시점이 오면 소멸한다.

<br/>

-------------

## 1. 인스턴스 생성
- 이니셜라이저(Initializer) 초기화 과정을 직접 구현할 수 있다. 구현된 이니셜라이저는 새로운 인스턴스를 생성할 수 있는 특별한 메서드가 된다.
- 스위프트의 이니셜라이저는 반환 값이 없다. 이니셜라이저의 역할은 그저 인스턴스의 첫 사용을 위해 초기화하는 것뿐이다.
- 이니셜라이저는 func 키워드를 사용하지 않고 오로지 init 키워드를 사용하여 이니셜라이저 메서드임을 표현한다.
- init 메서드 클래스, 구조체, 열거형 등의 구현부 또는 해당 타입의 익스텐션 구현부에 위치한다.

<br/>

### 1.1. 프로퍼티 기본값
- 구조체와 클래스의 인스턴스는 처음 생성할 때 옵셔널 저장 프로퍼티를 제외한 모든 저장프로퍼티에 적절한 초깃값(Initial Value)을 할당해야 한다.
- 이니셜라이저가 실행될때 저장 프로퍼티에 적절한 초깃값을 할당할 수 있다.
   - 초기화 후에 값이 확정되지 않은 저장 프로퍼티는 존재할 수 없다.
- 프로퍼티를 정의할 때 프로퍼티 기본값(Default Value)을 할당하면 이니셜라이저에서 따로 초깃값을 할당하지 않더라도 프로퍼티 기본값으로 저장 프로퍼티의 값이 초기화된다.

<br/>

### 1.2. 이니셜라이저 매개변수
- 함수나 메서드를 정의할 때와 마찬가지로 이니셜라이저도 매개변수를 가질 수 있다.
- 즉 인스턴스를 초기화하는 과정에 필요한 값을 전달받을 수 있다.

<br/>

### 1.3. 옵셔널 프로퍼티 타입
- 초기화 과정에서 값을 초기화하지 않아도 되는, 즉 인스턴스가 사용되는 동안에 값을 꼭 갖지 않아도 되는 저장 프로퍼티가 있다면 해당 프로퍼티를 옵셔널로 선언할 수 있다.
- 또는 초기화 과정에서 값을 지정해주기 어려운 경우 저장 프로퍼티를 옵셔널로 선언할 수 있다.
- 옵셔널로 선언한 저장 프로퍼티는 초기화 과정에서 값을 할당해주지 않으면 자동으로 nil이 할당된다.

<br/>

### 1.4. 상수 프로퍼티
- 상수로 선언된 저장 프로퍼티는 인스턴스를 초기화하는 과정에서만 값을 할당할 수 있으며, 처음 할당된 이후로는 값을 변경할 수 없다.

<br/>

### 1.5. 기본 이니셜라이저와 멤버와이즈 이니셜라이저
- 멤버와이즈 이니셜라이저는 구조체에서만 사용 가능하다.
- 사용자 정의 이니셜라이저를 정의해주지 않으면 클래스나 구조체는 모든 프로퍼티에 기본값이 지정되어 있다는 전제하에 기본 이니셜라이저를 사용한다.
- 즉 기본 이니셜라이저는 저장 프로퍼티의 기본값이 모두 지정되어 있고, 동시에 사용자 정의 이니셜라이저가 정의되어 있지 않은 상태에서 제공한다.
- 저장 프로퍼티를 선언할 때 기본값을 지정해주지 않으면 이니셜라이저에서 초깃값을 설정해야한다.
   - 하지만 매번 이니셜라이저를 추가하거나 변경하는 것은 매우 귀찮다
- 그렇기 때문에 구조체는 사용자 정의 이니셜라이저를 구현하지 않으면 프로퍼티의 이름으로 매개변수를 갖는 이니셜라이저인 멤버와이즈 이니셜라이저를 기본으로 제공한다.
   - 하지만 클래스는 멤버와이즈 이니셜라이저를 지원하지 않는다.

<br/>

### 1.6. 초기화 위임
- 값 타입인 구조체와 열거형은 코드의 중복을 피하기위해 이니셜라이저가 다른 이니셜라이저에게 일부 초기화를 위임하는 초기화 위임을 간단하게 구현 가능하다.
   - 클래스는 상속을 지원하기에 간단한 위임은 할 수 없다.
- 값 타입에서 이니셜라이저가 다른 이니셜라이저를 호출하려면 self.init을 사용한다. 당연히 self.init은 이니셜라이저 안에서만 사용 가능하지만 구조체와 열거형에서 self.init을 사용한다는 것 자체가 사용자 정의 이니셜라이저를 정의하고 있다는 뜻이다.
- 그러나 사용자 정의 이니셜라이저를 정의하면 기본 이니셜라이저와 멤버와이즈 이니셜라이저를 사용할 수 없다.
- 따라서 초기화 위임을 하려면 최소 두개 이상의 사용자 정의 이니셜라이저를 정의해야한다.
- 기본 이니셜라이저와 사용자 정의 이니셜라이저를 구분해야한다.

<br/>

### 1.7. 실패 가능 이니셜라이저(Failable initializer)
- init? 키워드를 사용한다.
- 이니셜라이저를 통해 인스턴스를 초기화할 수 없는 예외 상황들이 있다. 대표적으로 이니셜라이저의 전달인자로 잘못된 값이나 적절치 못한 값이 전달되었을때 이니셜라이저는 인스턴스 초기화에 실패할 수 있다.
- 이니셜라이저를 정의할때 실패 가능성을 내포한 이니셜라이저를 실패 가능 이니셜라이저라고 한다.
- 실패 가능 이니셜라이저는 클래스, 구조체, 열거형 등 모두에서 정의 할 수 있다.
   - 열거형에서 더 유용하게 사용할 수 있다.
- 실패 가능 이니셜라이저는 실패했을 때 nil을 반환해주므로 반환 타입이 옵셔널로 지정된다.

<br/>

--------
## 2. 인스턴스 소멸(Deinitializer, 디이니셜라이저)
- deinit 키워드를 사용한다.
- 클래스에서 사용가능하다.
   - 클래스에서 단 하나의 디이니셜라이저만 구현할 수 있다.
   - 메모리를 스택 영역에서 사용하고 곧바로 종료하는 구조체와 달리 힙 영역에 자신의 메모리를 할당 후 저장하고 있는 클래스이다.
- 디이니셜라이저는 이니셜라이저와 반대 역할을 한다.
   - 즉, 메모리에서 해제(소멸)되기 바로 직전 클래스 인스턴스와 관련하여 원하는 정리 작업을 구현 할 수 있다.
- 디이니셜라이저는 이니셜라이저와 달리 매개변수를 갖지 않으며, 소괄호도 적어주지 않는다. 또한 자동으로 호출되기 때문에 별도의 호출 코드를 사용할 수 없다.
- 스위프트는 인스턴스가 더 이상 필요하지 않으면 자동으로 메모리에서 소멸시킨다. 인스턴스 대부분은 소멸시킬 때 디이니셜라이저를 사용해 메모리 관리 작업을 할 필요는 없다.
   - 그렇지만 예로 인스턴스 내부에서 파일을 불러와 열어보는 등의 외부 자원을 사용했다면 인스턴스를 소멸하기 직전에 파일을 다시 저장하고 닫아주는 등의 부가 작업을 해야한다. 이런 경우 유용하게 사용할 수 있다.
- 디이ㄴ
   - 그렇지만 예로 인스턴스 내부에서 파일을 불러와 열어보는 등의 외부 자원을 사용했다면 인스턴스를 소멸하기 직전에 파일을 다시 저장하고 닫아주는 등의 부가 작업을 해야한다. 이런 경우 유용하게 사용할 수 있다
- 디이니셜라이저를 잘 활용하면 메모리 관리 측면 외에도 프로그래머가 설계한 로직에 따라 인스턴스가 메모리에서 해제되기 직전에 적절한 작업을 하도록 할 수 있다.
