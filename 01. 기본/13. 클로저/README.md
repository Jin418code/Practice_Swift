# 1. 클로저(Closure)
- 클로저를 잘 이해해야 스위프트의 함수형 프로그래밍 패러다임 스타일을 좀 더 명확하게 이해할 수 있다.
   - 클로저와 제너릭(Genrics), 프로토콜(Protocol), 모나드(Monad) 등이 있다.
- 클로저는 변수가 상수가 선언된 위치에서 참조(Reference)를 획득(Capture)하고 저장할 수 있다.
   - 이를 변수나 상수의 클로징(잠금)이라고 한다.
- 획득 때문에 메모리에 부담이 가지 않을까 걱정할 수도 있지만, 앞서 설명했듯이 스위프트는 스스로 메모리를 관리한다. 

<br/>

- 클로저는 세 가지형태가 있다.
1. 이름이 있으면서 어떤 값도 획득하지 않는 전역함수의 형태
2. 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 중첩된 함수의 형태
3. 이름이 없고 주변 문맥에 따라 값을 획득할 수 있는 축약 문법으로 작성한 형태

<br/>

- 클로저를 통해 다양하게 표현할 수 있다.
1. 클로저는 매개변수와 반환 값의 타입을 문맥을 통해 유추할 수 있기 때문에 매개변수와 반환 값의 타입을 생략 할 수 있다.
2. 클로저에 단 한줄의 표현만 들어있다면 암시적으로 이를 반환 값으로 취급한다.
3. 축약된 전달인자 이름을 사용할 수 있다.
4. 후행 클로저 문법을 사용할 수 있다.

## 1.1. 기본 클로저
### sorted(by:)
- 스위프트 표준 라이브러리에는 배열의 값을 정렬하기 위해 구현한 sorted(by:) 메서드가 있다.
- 이 메서드는 클로저를 통해 어떻게 정렬할 것인가에 대한 정보를 받아 처리하고 결괏값을 배열로 돌려준다.
- 단순히 정렬만 하기 때문에 입력받은 배열의 타입과 크기가 동일하다. 기존의 배열은 변경하지 않고 정렬된 배열을 새로 생성하여 반환해준다.
```
{ (매개변수들) -> 반환 타입 in
실행 코드
}
```
- 클로저도 함수와 마찬가지로 입출력 매개변수를 사용할 수 있다. 매개변수 이름을 지정한다면 가변 매개변수 또한 사용가능하다.
   - 다만 클러저는 매개변수 기본값을 사용할 수 없다. 
### backwards(first:second:)
- sorted(by:) 메서드로 전달하는 클로저의 매개변수 개수와 타입, 반환 타입이 모두 backwards(first:second:) 같다.

<br/>

-----------
# 2. 후행 클로저(Trailing Closure)
- 함수나 메서드의 마지막 전달인자로 위치하는 클로저는 함수나 메서드의 소괄호를 닫은 후 작성해도 된다.
- 클로저가 조금 길어지거나 가독성 조금 떨어진다 싶으면 후행 클로저 기능을 사용하면 좋다.
- Xcode에서 자동완성 기능을 사용하면 자동으로 후행 클로저로 유도한다.
- 단, 후행 클로저는 맨 마지막 전달인자로 전달되는 클로저에만 해당되므로 전달인자로 클로저 여러 개를 전달할 때는 맨 마지막 클로저만 후행 클로저로 사용할 수 있다.
- 매개변수에 클로저가 여러개 있는 경우, 다중 후행 클로저 문법을 사용할 수 있다.
   - 다중 후행 클로저를 사용하는 경우, 중괄호를 열고 닫음으로써 클로저를 표현하며 첫번째 클로저의 전달인자 레이블은 생략한다.

<br/>

-----------
# 3. 클로저 표현 간소화

## 3.1. 문맥을 이용한 타입 유추
- 메서드의 전달인자로 전달하는 클로저는 메서드에서 요구하는 형태로 전달해야한다.
   - 즉, 매개변수의 타입이나 개수, 반환 타입 등이 같아야 전달인자로서 전달할 수 있다.
   - 전달인자로 전달한 클로저는 이미 적합한 타입을 준수하고 있다고 유추할수 있다.
- 그래서 전달인자로 전달하는 클로저를 구현할 때는 매개변수의 타입이나 반환 값의 타입을 굳이 표현해주지 않고 생략하더라도 문제가 없다.

<br/>

## 3.2. 단축 인자 이름
- 계속해서 sorted(by:) 메서드로 전달하는 클로저는 first, second와 같은 매개변수 이름을 사용한다.
   - 단축 인자 이름은 첫번째 전달인자부터 $0, $1, $2 ... 순서로 사용 가능하다.

<br/>

## 3.3. 암시적 반환 표현
- 클로저에서 return 키워드도 생략 가능하다.
- 클로저가 반환 값을 갖는 클로저이고 클로저 내부의 실행문이 단 한 줄이라면, 암시적으로 그 실행문을 반환 값으로 사용할 수 있다.

<br/>

## 3.4. 연산자 함수
- 클로저의 장점은 간단한 표현이다.
- 비교 연산자는 두 개의 피연산자를 통해 Bool타입의 반환을 준다. sorted(by:) 메서드에 전달한 클로저와 동일한 조건이며 클로저는 매개변수의 타입과 반환 타입이 연산자를 구현한 함수의 모양과 동일하다면 연산자만 표기하더라도 알아서 연산하고 반환한다.

<br/>

------------

# 4. 값 획득
- 클로저는 자신이 정의된 위치의 주변 문맥을 통해 상수나 변수를 획득(Capture)할 수 있다.
- 값 획득을 통해 클로저는 주변에 정의한 상수나 변수가 더 이상 존재하지 않더라도 해당 상수나 변수의 값을 자신 내부에서 참조하거나 수정할 수 있다.
   - 클로저는 비동기 작업에 많이 사용된다.
- 클로저를 통해 비동기 콜백(Call-back)을 작성하는 경우, 현재 상태를 미리 획득해두지 않으며, 실제로 클로저의 기능을 실행하는 순간에는 주변의 상수나 변수가 이미 메모리에 존재하지 않는 경우가 발생한다.
- 중첩 함수도 하나의 클로저 형태로, 이 중첩 함수 주변의 변수나 상수를 획득해 놓을 수도 있다. 즉, 자신을 포함하는 함수의 지역변수나 지역상수를 획득할 수 있다.

<br/>

-------------

# 5. 클로저는 참조 타입
- 함수나 클로저는 상수나 변수에 할당할 때마다 상수나 변수에 함수나 클로저의 참조를 설정하는 것이다.

<br/>

-------------

# 6. 탈출 클로저
- 함수의 전달인자로 전달한 클로저가 함수 종료 후에 호출될 때 클로저가 함수르 탈출(Escape)한다고 표현한다.
- 클로저를 매개변수로 갖는 함수를 선언할 때 매개변수 이름의 콜론 뒤에 @escaping 키워드를 사용하여 클로저가 탈출하느 것을 허용한다고 명시해줄 수 있다.
- 비동기 작업으로 함수가 종료되고 난 후 호출할 필요가 있는 클로저를 사용해야야 할 때 탈출 클로저(Escaping Closure)가 필요하다.
- 정렬할 요소를 비교 연산하기 위해 전달인자로 전달하는 클로저는 비탈출 클로저(Nonescape Closure)이다.
- 클로저가 탈출할 수 있는 경우 중 하나는 함수 외부에 정의된 변수나 상수에 저장되어 함수가 종료된 후에 사용할 수 있는 경우이다.

## 6.1. withoutActuallyEscaping
- 
